
# Leetcode-1266. Minimum Time Visiting All Points
## 題目說明
在一個二維平面上，有 `n` 個點，每個點的座標均為整數，記為 `points[i] = [xi, yi]`。傳回以 `points` 陣列順序存取所有點所需的最短時間（以秒為單位）。

您可以按照以下規則移動：

在 1 秒內，您可以：

垂直移動 1 個單位，

水平移動 1 個單位，或

沿對角線移動 `sqrt(2)` 個單位（換句話說，在 1 秒內先垂直移動 1 個單位，再水平移動 1 個單位）。

您必須按照數組中點的順序存取它們。

您可以經過順序中後面的點，但這些點不計入訪問次數。

### 限制條件：
- `points.length == n`。
- `1 <= n <= 100`。
- `points[i].length == 2`。
- `-1000 <= points[i][0], points[i][1] <= 1000`。

## 解題思路
目標是計算依序走訪所有給定座標點所需的最短時間。每一秒可以在平面上往上下、左右，或是對角線方向移動一步，因此在一次移動中，`x` 與 `y` 座標都可以同時改變 `1`。

解題的關鍵觀察在於：從一個點移動到下一個點時，最佳策略永遠是「能走對角線就盡量走對角線」。因為對角線移動可以同時縮小 `x` 與 `y` 的距離，比單獨只在水平方向或垂直方向移動更有效率。

假設目前點是 `(x1, y1)`，下一個點是 `(x2, y2)`，在每一秒中最多只能讓 `x` 改變 `1`、`y` 改變 `1`。要把 `x` 的差距 `|x2 − x1|` 與 `y` 的差距 `|y2 − y1|` 都消除掉，最少需要的時間，其實就是這兩個差距中的較大者。因為在較小的那個差距用完之前，可以一直走對角線，同時縮小兩個方向；等其中一個方向歸零後，剩下的距離只能直線走完。

因此，從一個點到下一個點所需的最短時間，就是
`max(|x2 − x1|, |y2 − y1|)`。

整體做法就是依序走訪 `points` 陣列，對每一對相鄰的點計算上述距離，並將結果累加起來，就是走完所有點的最短總時間。

時間複雜度方面，程式只需要一次線性掃描所有點，每一段移動的計算都是常數時間，因此整體時間複雜度是 `O(n)`，其中 n 是點的數量。

空間複雜度方面，只使用了幾個變數來記錄座標與答案，沒有額外使用與輸入大小相關的資料結構，所以空間複雜度是 `O(1)`。

## 參考解法
```cpp title="C++" showLineNumbers
class Solution {
public:
    int maxSumDivThree(vector<int>& nums) {
        vector<int> dp(3, INT_MIN);
        dp[0] = 0;

        for (int x : nums) {
            vector<int> new_dp(dp); // 先複製

            for (int r = 0; r < 3; ++r) {
                if (dp[r] != INT_MIN) {
                    int new_r = (r + x % 3) % 3;
                    new_dp[new_r] = max(new_dp[new_r], dp[r] + x);
                }
            }

            dp = new_dp;
        }

        return dp[0];
    }
};
```