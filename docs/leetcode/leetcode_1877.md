
# Leetcode-1877. Minimize Maximum Pair Sum in Array
## 題目說明
元素對 `(a, b)` 的和等於 `a + b`。最大和是指一組元素對中最大的和。

例如，如果一組元素對是 `(1, 5)`、`(2, 3)` 和 `(4, 4)`，那麼最大和就是 `max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8`。

給定一個長度為偶數 `n` 的陣列 `nums`，將 `nums` 中的元素兩兩配對，使得：


- `nums` 中的每個元素恰好屬於一個元素對，並且

- 最大元素對之和最小。

傳回經過最優配對後最大和最小的值。

### 限制條件：
- `n == nums.length`。
- `2 <= n <= 10^5`。
- `n` 為偶數。
- `1 <= nums[i] <= 10^5`。

## 解題思路
題目要求將數字兩兩配對，目標是讓 「所有配對中，和最大的那一組」 數值越小越好。

為了達到這個目標，我們必須讓每一組的總和盡量 「平均」。如果我們讓兩個很大的數字配在一起，那一組的和就會衝得非常高，這就違反了我們要「最小化最大值」的目標。

具體步驟
先排序 (`Sorting`)： 首先將陣列由小到大排序。這是最關鍵的一步，因為排序後我們才能清楚知道哪些是小數、哪些是大數。

頭尾配對 (`Max` 配 `Min`)： 為了壓低最大那一組的和，最好的策略是 「互補」：

拿陣列中 目前最大 的數字（尾端），去配陣列中 目前最小 的數字（開頭）。

拿 "第二大" 的數字，去配 "第二小" 的數字。

依此類推，直到所有數字都配對完成。

為什麼這樣做？ 想像你有一個很高的波峰（大數）和一個很深的波谷（小數），把它們加在一起，波峰就會被削平，整體的高度就會變得比較平均。如果你把兩個大數加在一起，波峰只會變得更高。

找出這些配對中的最大值： 在遍歷配對的過程中（你的 `for` 迴圈），計算每一組 `nums[i] + nums[n-i-1]` 的和。題目要問的是這些配對後的結果中「最大的」那個是多少，所以我們用 `max()` 函式持續更新並紀錄目前遇到的最大和。

## 參考解法
```cpp title="C++" showLineNumbers
class Solution {
public:
    int minPairSum(vector<int>& nums) {
        int n = nums.size();
        int minsum = 0;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n / 2; i++) {
            minsum = max(minsum, nums[i] + nums[n - i - 1]);
        }
        return minsum;
    }
};
```