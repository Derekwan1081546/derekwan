
# Leetcode-3379. Transformed Array
## 題目說明
給定一個表示循環數組的整數數組 `nums`，你的任務是創建一個大小相同的新數組 `result`，並遵循以下規則：

對於每個索引 `i`（其中 0 <= i < nums.length），請執行下列操作：

如果 `nums[i] > 0`：從索引 `i` 開始，在循環陣列中向右移動 `nums[i]` 個步長。將 `result[i]` 設定為目前索引對應的值。

如果 `nums[i] < 0`：從索引 `i` 開始，在循環陣列中向左移動 `abs(nums[i])` 個步長。將 `result[i]` 設定為目前索引對應的值。

如果 `nums[i] == 0`：將 `result[i]` 設為 `nums[i]`。

傳回新數組 `result`。

注意：由於 `nums` 是循環數組，移動到最後一個元素之後會循環回到數組的開頭，移動到第一個元素之前會循環回到數組的末尾。

### 限制條件：
- `1 <= nums.length <= 100`。
- `-100 <= nums[i] <= 100`。


## 解題思路

這段程式碼的目標是根據陣列 `nums` 中每個元素的值來構建一個新的轉換陣列 `ans`。
題目核心在於處理 **循環索引 (Circular Indexing)**：對於每個元素 `nums[i]`，我們需要找到從索引 `i` 移動 `nums[i]` 步後的新位置。由於移動後可能會超出陣列邊界（溢出）或是負數（往回走），因此需要特殊的取模運算來處理。

1.  **初始化**：
    建立一個空的 `vector<int>` 名為 `ans` 用來儲存結果，並獲取陣列長度 `n`。

2.  **遍歷陣列**：
    使用 `for` 迴圈遍歷 `nums` 的每一個索引 `i`。

3.  **計算目標索引 (核心邏輯)**：
    `int index = ((i + nums[i]) % n + n) % n;`
    這行程式碼完美處理了所有邊界情況：
    * **正常移動**：`i + nums[i]` 計算初步的新位置。
    * **處理負數**：如果 `nums[i]` 是負數且導致 `i + nums[i]` 為負值，C++ 的 `%` 運算符可能會保留負號（例如 `-2 % 5 = -2`）。
    * **修正負數**：透過 `+ n`，將負餘數轉為正數（例如 `-2 + 5 = 3`）。
    * **再次取模**：最後的 `% n` 是為了處理原本就是正數且 `+ n` 後超過範圍的情況，或者確保結果落在 `0` 到 `n-1` 之間。

    簡而言之，這個公式將陣列視為一個首尾相接的圓環，無論正向移動（正數）或反向移動（負數），都能精確定位到正確的索引。

4.  **填充結果**：
    將計算出的目標位置的值 `nums[index]` 加入 `ans`。

---

### 複雜度分析

* **時間複雜度：$O(N)$**
    其中 $N$ 是陣列 `nums` 的長度。我們只需要遍歷陣列一次，且內部的數學運算和 `push_back` 都是 $O(1)$ 的操作。

* **空間複雜度：$O(N)$**
    我們建立了一個新的陣列 `ans` 來儲存結果，大小與輸入陣列相同。
    *(若不計算回傳值所需的空間，輔助空間複雜度為 $O(1)$)*

## 參考解法
```cpp title="C++" showLineNumbers
class Solution {
public:
    vector<int> constructTransformedArray(vector<int>& nums) {
        vector<int> ans;
        int n = nums.size();
        for (int i = 0; i < nums.size(); i++) {
            int index = ((i + nums[i]) % n + n) % n;
            ans.push_back(nums[index]);
        }
        return ans;
    }
};
```

