
# Leetcode-3713. Longest Balanced Substring I
## 題目說明
給定一個由小寫英文字母組成的字串 `s`。

如果子字串中所有不同的字元出現的次數相同，則稱該子字串為平衡子字串。

傳回 `s` 中最長的平衡子字串的長度。

### 限制條件：
- `1 <= s.length <= 1000`。
- `s` 由小寫英文字母組成。


## 解題思路

這題的目標是尋找最長的 **「頻率平衡 (Frequency Balanced)」** 子字串。
根據程式碼邏輯，這裡對「平衡」的定義是：**子字串中每一個出現過的字元，其出現次數都相同**。

由於平衡的條件不具備單調性（不能單純用滑動視窗擴張），我們必須採用 **枚舉法 (Enumeration)** 搭配 **數學驗證** 來解決。

我們可以透過 **雙層迴圈枚舉** 加上 **剪枝 (Pruning)** 來優化效率：

1.  **枚舉策略 (Enumeration Strategy)**
    * 使用雙層迴圈遍歷所有可能的子字串 `s[i...j]`。
    * 外層迴圈固定起點 `i`，內層迴圈延伸終點 `j`。
    * **剪枝優化**：在每輪外層迴圈開始時，檢查 `if (n - i <= max_len)`。如果剩下的字串長度已經小於目前找到的最大長度，則不可能再更新答案，直接 `break` 結束迴圈。

2.  **狀態維護 (State Maintenance)**
    * 為了避免每次都重新掃描子字串，我們在內層迴圈延伸時動態維護狀態：
    * `freq[26]`：記錄 'a'-'z' 目前的出現次數（使用陣列比 Map 快）。
    * `max_freq`：記錄目前出現 **最多次** 的頻率。
    * `distinct`：記錄目前有 **幾種** 不同的字元。

3.  **核心驗證邏輯 (Validation Logic)**
    * 如何快速判斷子字串是否平衡？
    * 若子字串是平衡的，則所有出現過的字元頻率都必須等於 `max_freq`。
    * 因此，子字串的總長度必須滿足公式：**`current_len == max_freq * distinct`**。
    * *範例：`"aabbcc"` (長度6) = `2` (最大頻率) * `3` (相異字元數)。成立。*
    * *範例：`"aab"` (長度3) != `2` (最大頻率) * `2` (相異字元數)。不成立。*

---

### 複雜度分析

* **時間複雜度：$O(N^2)$**
    * 程式碼包含兩層巢狀迴圈，總共遍歷的子字串數量約為 $\frac{N(N+1)}{2}$。
    * 在迴圈內部，陣列存取、變數更新與數學判斷皆為 $O(1)$ 操作。
    * 總體時間複雜度為 $O(N^2)$。對於 $N \le 2000$ 的限制，運算量約 $2 \times 10^6$，可安全通過。

* **空間複雜度：$O(1)$**
    * 我們只使用了一個固定大小為 26 的整數陣列 `freq` 來儲存字母頻率。
    * 無論輸入字串長度 $N$ 為何，所需的額外記憶體空間都是固定的（僅與字元集大小 $\Sigma = 26$ 相關）。
## 參考解法
```cpp title="C++" showLineNumbers
class Solution {
public:
    int longestBalanced(string s) {
        int n = s.size();
        int max_len = 0;

        // 外層迴圈：枚舉子字串的起點 i
        for (int i = 0; i < n; ++i) {

            // 優化：如果剩下的長度已經小於當前找到的最大長度，就不用繼續了
            if (n - i <= max_len)
                break;

            int freq[26] = {0}; // 用來記錄 a-z 的頻率，比 map 快很多
            int max_freq = 0;   // 當前子字串中，出現最多次的字元的次數
            int distinct = 0;   // 當前子字串中，有多少種不同的字元

            // 內層迴圈：枚舉子字串的終點 j
            for (int j = i; j < n; ++j) {
                int idx = s[j] - 'a'; // 將字元轉換為 0-25 的索引

                // 如果這個字元第一次出現，相異字元數 +1
                if (freq[idx] == 0) {
                    distinct++;
                }

                freq[idx]++;

                // 更新最大頻率
                max_freq = max(max_freq, freq[idx]);

                // 計算當前子字串長度
                int current_len = j - i + 1;

                // 核心判斷：長度 是否等於 (最大頻率 * 相異字元數)
                // 例如 "aabbcc": 長度6, 最大頻率2, 種類3 => 2*3 == 6 (平衡)
                // 例如 "aab":    長度3, 最大頻率2, 種類2 => 2*2 != 3 (不平衡)
                if (current_len == max_freq * distinct) {
                    max_len = max(max_len, current_len);
                }
            }
        }
        return max_len;
    }
};
```
