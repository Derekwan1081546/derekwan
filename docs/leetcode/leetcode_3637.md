
# Leetcode-3637. Trionic Array I
## 題目說明
給定一個長度為 n 的整數數組 nums。

若存在索引 0 < p < q < n − 1，使得：

`nums[0...p]` 嚴格遞增，

`nums[p...q]` 嚴格遞減，

`nums[q...n − 1]` 嚴格遞增，則稱為三元數組。

如果 `nums` 是三元數組，則傳回 `true`，否則傳回 `false`。

### 限制條件：
- `3 <= n <= 100`。
- `-1000 <= nums[i] <= 1000`。

## 解題思路

這段程式碼的目標是判斷一個陣列是否為 **Trionic Array**（三相陣列）。根據邏輯推斷，Trionic 的定義應為一個「N」字形結構：先嚴格遞增、再嚴格遞減、最後再嚴格遞增。

程式碼採用 **模擬法 (Simulation)**，利用三個 `while` 迴圈依序檢查這三個階段是否完整存在且連續。

1.  **第一階段：尋找第一個峰值 (Peak $p$)**
    * `while (i < n && nums[i - 1] < nums[i])`：從陣列開頭開始，只要目前元素比前一個大（遞增），就繼續往後走。
    * `int p = i - 1;`：迴圈停止處的前一個位置即為遞增段的結束點 $p$。

2.  **第二階段：尋找谷底 (Valley $q$)**
    * `while (i < n && nums[i - 1] > nums[i])`：接著檢查遞減段，只要目前元素比前一個小，就繼續往後走。
    * `int q = i - 1;`：迴圈停止處的前一個位置即為遞減段的結束點 $q$。

3.  **第三階段：尋找結尾 (End)**
    * `while (i < n && nums[i - 1] < nums[i])`：最後檢查第二段遞增，繼續往後走直到不滿足遞增條件或陣列結束。
    * `int flag = i - 1;`：記錄最後停下的位置。

4.  **合法性驗證 (Validation)**
    最後回傳 `true` 的條件必須同時滿足：
    * `p != 0`：第一段遞增必須存在（不能一開始就沒上升）。
    * `q != p`：遞減段必須存在（峰值 $p$ 和谷底 $q$ 不能是同一點，意即至少下降了一步）。
    * `flag == n - 1`：必須遍歷完整個陣列（不能半路中斷）。
    * `flag != q`：第二段遞增必須存在（結尾不能等於谷底 $q$，意即最後至少上升了一步）。

---

### 複雜度分析

* **時間複雜度：$O(N)$**
    其中 $N$ 是陣列長度。雖然有多個 `while` 迴圈，但索引變數 `i` 從頭到尾只會增加，每個元素最多被訪問一次。

* **空間複雜度：$O(1)$**
    只使用了少量的變數 `i`, `p`, `q`, `flag` 來記錄索引，不需要額外的記憶體空間。

## 參考解法
```cpp title="C++" showLineNumbers
class Solution {
public:
    bool isTrionic(vector<int>& nums) {
        int n = nums.size(), i = 1;
        while (i < n && nums[i - 1] < nums[i]) {
            i++;
        }
        int p = i - 1;
        while (i < n && nums[i - 1] > nums[i]) {
            i++;
        }
        int q = i - 1;
        while (i < n && nums[i - 1] < nums[i]) {
            i++;
        }
        int flag = i - 1;
        return (p != 0) && (q != p) && (flag == n - 1 && flag != q);
    }
};
```
