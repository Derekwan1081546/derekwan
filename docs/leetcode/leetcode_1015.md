
# Leetcode-1015. Smallest Integer Divisible by K
## 題目說明
給定一個正整數 `k`，你需要找出最小的正整數 `n` 的長度，使得 `n` 能被 `k` 整除，且 `n` 只包含數字 `1`。

傳回 `n` 的長度。如果不存在這樣的 `n`，則傳回 `-1`。

注意：`n` 可能無法以 64 位元有符號整數(`signed integer`)表示。

### 限制條件：
- `1 <= k <= 10＾5`。

## 解題思路
題目要找由全部是數字 `1` 組成的整數，例如 `1`、`11`、`111`…，其中最短的一個能被 `k` 整除的位數。
首先，如果 `k` 含有 `2` 或 `5` 的因數，這種全 `1` 數字永遠不可能被它整除，因此直接回傳 `-1`。

接著，我們不需要真的組出巨大數字，而是用「餘數」來代表目前形成的全 `1` 數字。
每增加一位 `1`，相當於把前一個數字乘上 `10` 再加 `1`，我們用模 `k` 的方式更新餘數。
如果某一步的餘數變成 `0`，表示這個長度的全 `1` 數字可以被 `k` 整除，因此回傳該長度。

餘數最多只有 `k` 種可能，如果重複 `k` 次都沒有出現 `0`，表示會無限循環、不會整除，最後回傳 `-1`。

## 參考解法
```cpp title="C++" showLineNumbers
class Solution {
public:
    int smallestRepunitDivByK(int k) {
        if (k % 2 == 0 || k % 5 == 0)
            return -1;
        int rem = 0;
        for (int i = 1; i <= k; i++) {
            rem = (rem * 10 + 1) % k;
            if (rem == 0)
                return i;
        }
        return -1;
    }
};
```